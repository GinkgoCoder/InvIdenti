/*
       ///Set dataset format
        FastVector var0 = new FastVector();

        attributes.add(new Attribute("Assignee", (FastVector) null));

        attributes.add(new Attribute("Category", (FastVector) null));



        if (true) {
            for (int i = 0; i < patents.get(0).getTd().rows(); i++) {
                attributes.add(new Attribute("FullText" + Integer.toString(i)));

            }
            attributesNumber.put("FullText",patents.get(0).getTd().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_abs().rows(); i++) {
                attributes.add(new Attribute("Abstract" + Integer.toString(i)));

            }
            attributesNumber.put("Abstract",patents.get(0).getTd_abs().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_claims().rows(); i++) {
                attributes.add(new Attribute("Claims" + Integer.toString(i)));

            }
            attributesNumber.put("Claims",patents.get(0).getTd_claims().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_des().rows(); i++) {
                attributes.add(new Attribute("Description" + Integer.toString(i)));

            }
            attributesNumber.put("Description",patents.get(0).getTd().rows());
        }
        int index=0;

        for (Attribute var1 : attributes) {
            var0.addElement(var1);
            attributeIndex.put(var1.name(), index);
            index++;
        }

        this.attriInfo=new pair<>(attributeIndex,attributesNumber);

        //Initialize the dataset
        instances = new Instances("Patent", var0, patents.size());

        for (int i = 0; i < patents.size(); i++) {
            Instance var3 = new Instance(attributes.size());
            var3.setDataset(instances);
            var3.setValue(var3.attribute(attributeIndex.get("Assignee")), patents.get(i).getAssignee());
            var3.setValue(var3.attribute(attributeIndex.get("Category")), patents.get(i).getCategory());

            if ( true) {
                for (int j = 0; j < patents.get(0).getTd().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("FullText" + Integer.toString(j))), patents.get(i).getTd().get(j, 0));
                }
            }
            if (true) {
                for (int j = 0; j < patents.get(0).getTd_abs().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Abstract" + Integer.toString(j))), patents.get(i).getTd_abs().get(j, 0));
                }
            }
            if ( true) {
                for (int j = 0; j < patents.get(0).getTd_claims().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Claims" + Integer.toString(j))), patents.get(i).getTd_claims().get(j, 0));
                }
            }
            if ( true) {
                for (int j = 0; j < patents.get(0).getTd_des().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Description" + Integer.toString(j))), patents.get(i).getTd_des().get(j, 0));
                }
            }
            instances.add(var3);
        }
        */



        package preprocessing;

        import base.pair;
        import base.patent;
        import com.carrotsearch.hppc.IntArrayList;
        import com.carrotsearch.hppc.IntIntHashMap;
        import com.carrotsearch.hppc.cursors.IntIntCursor;
        import org.apache.mahout.math.matrix.DoubleMatrix2D;
        import org.apache.mahout.math.matrix.impl.DenseDoubleMatrix2D;
        import org.carrot2.core.Document;
        import org.carrot2.core.LanguageCode;
        import org.carrot2.text.preprocessing.LabelFormatter;
        import org.carrot2.text.preprocessing.PreprocessingContext;
        import org.carrot2.text.preprocessing.pipeline.BasicPreprocessingPipeline;
        import org.carrot2.text.preprocessing.pipeline.CompletePreprocessingPipeline;
        import org.carrot2.text.preprocessing.pipeline.IPreprocessingPipeline;
        import org.carrot2.text.vsm.ReducedVectorSpaceModelContext;
        import org.carrot2.text.vsm.TermDocumentMatrixBuilder;
        import org.carrot2.text.vsm.TermDocumentMatrixReducer;
        import org.carrot2.text.vsm.VectorSpaceModelContext;


        import java.util.*;

        /**
         * Created by sunlei on 15/9/7.
         */
        public class patentPreprocessingTF {
            ArrayList<Document> docs = new ArrayList<>();
            ArrayList<patent> patents = new ArrayList<>();
            LanguageCode language = LanguageCode.ENGLISH;
            public int clusterCount = 15;
            public boolean useDimensionalityReduction = false;

            public IPreprocessingPipeline preprocessingPipeline = new BasicPreprocessingPipeline();
            public final TermDocumentMatrixBuilder matrixBuilder = new TermDocumentMatrixBuilder();

            public final TermDocumentMatrixReducer matrixReducer = new TermDocumentMatrixReducer();
            public final LabelFormatter labelFormatter = new LabelFormatter();

            public patentPreprocessingTF(ArrayList<patent> Pts) {
                this.patents = Pts;
                /**
                 * Set the matrix size to build the term frequency.
                 */
                this.matrixBuilder.maximumMatrixSize=250*150*4;
            }

            public void setLanguage(LanguageCode code) {
                this.language = code;
            }

            public void setClusterCount(int ClusterCount) {
                this.clusterCount = ClusterCount;
            }

            public void setUseDimensionalityReduction(boolean r) {
                this.useDimensionalityReduction = r;
            }

            public ArrayList<patent> getPatents()
            {
                return this.patents;
            }

            public void preprocess()
            {
        //        this.generateTextVector("FullText");
                this.generateTextVector("Abstract");
                this.generateTextVector("Claims");
                this.generateTextVector("Description");
                this.generateTextVector("Title");

            }

            public void generateTextVector(String str)
            {

                //Build arrayList of docs
                for (patent p : patents)
                {
                    String temp=" ";
                    if (str.equalsIgnoreCase("Abstract")) temp=p.getAbs();
                    if (str.equalsIgnoreCase("Claims"))   temp=p.getClaims();
                    if (str.equalsIgnoreCase("Description")) temp=p.getDescription();
                    if (str.equalsIgnoreCase("Title")) temp=p.getTitle();
                    pair<ArrayList<String>,double[]> var0;

                    if (!str.equalsIgnoreCase("Title")) {
                        var0 =TFcalculation(temp,1);
                    } else {
                        var0=TFcalculation(temp,1);
                    }
                    double[][] var1=new double[var0.secondarg.length][1];
                    int i=0;
                    for(double var2:var0.secondarg) {
                        var1[i][0]=var2;
                        i++;
                    }

                    if (str.equalsIgnoreCase("Abstract")) {
                        p.setTd_abs(new DenseDoubleMatrix2D(var1));
                        p.absStems=var0.firstarg;
                        //p.setAbs(null);
                    }
                    if (str.equalsIgnoreCase("Claims"))  {
                        p.setTd_claims(new DenseDoubleMatrix2D(var1));
                        p.claimsStems=var0.firstarg;
                      //  p.setClaims(null);
                    }
                    if (str.equalsIgnoreCase("Description")) {
                        p.setTd_des(new DenseDoubleMatrix2D(var1));
                        p.desStems=var0.firstarg;
                    //    p.setDescription(null);
                    }
                    if (str.equalsIgnoreCase("Title")) {
                        p.setTd_title(new DenseDoubleMatrix2D(var1));
                        p.titleStems=var0.firstarg;
                        //p.setTitle(null);
                    }


                }




            }


            public static pair<ArrayList<String>,double[]> TFcalculation(String var0,double threshold) {

                IPreprocessingPipeline preprocessingPipeline = new BasicPreprocessingPipeline();
                ArrayList<Document> docs = new ArrayList<>();
                docs.add(new Document(" ", var0));
                PreprocessingContext preprocessingContext = preprocessingPipeline.preprocess(docs, (String) null, LanguageCode.ENGLISH);
                int[] stemsMfow = preprocessingContext.allStems.mostFrequentOriginalWordIndex;
                short[] wordsType = preprocessingContext.allWords.type;


                IntArrayList featureIndices = new IntArrayList(stemsMfow.length);
                for (int vsmContext = 0; vsmContext < stemsMfow.length; ++vsmContext) {
                    short reducedVsmContext = wordsType[stemsMfow[vsmContext]];
                    if ((reducedVsmContext & 12290) == 0) {
                        featureIndices.add(stemsMfow[vsmContext]);
                    }
                }



                int[] stemType=new int[preprocessingContext.allStems.tf.length];
                for(int i=0;i<wordsType.length;i++) {
                    if((wordsType[i]&12290)!=0) {
                       stemType[preprocessingContext.allWords.stemIndex[i]]=0;
                    } else {
                        stemType[preprocessingContext.allWords.stemIndex[i]]=1;

                    }
                }


                int numofStem=0;
                for(int var=0;var<stemType.length;var++) {
                if (stemType[var]==1) numofStem++;
               }


                double[] tfMatrix = new double[numofStem];

                int i=0;
                for (int j = 0; j < preprocessingContext.allStems.tfByDocument.length; j ++) {
                   if (stemType[j]==1) {
                       tfMatrix[i]=preprocessingContext.allStems.tfByDocument[j][1];
                       i++;
                   }
                }

                double sum=0;

                for(double var1:tfMatrix) {
                    sum+=var1;
                }

                for(int vari=0;vari<tfMatrix.length;vari++) {
                    tfMatrix[vari]/=sum;
                }

                ArrayList<Double> var1=new ArrayList<>();

                for(double vari:tfMatrix) {
                    var1.add(vari);
                }


              //  System.out.println(preprocessingContext.allWords);

                //System.out.println(preprocessingContext.allStems);

                ArrayList<String> stems=new ArrayList<>();
                for(int vari=0;vari<preprocessingContext.allStems.tf.length;vari++) {

                   if(stemType[vari]==1) {
                    String varTemp=String.copyValueOf(preprocessingContext.allStems.image[vari]);
                    stems.add(varTemp);
                   }

                }
                HashMap<Double,ArrayList<String>> stemsWithTF=new HashMap<>();

                for(int vari=0;vari<tfMatrix.length;vari++) {
                    if(stemsWithTF.containsKey(tfMatrix[vari])) {
                        stemsWithTF.get(tfMatrix[vari]).add(stems.get(vari));
                    }
                    else {
                        ArrayList<String> temp=new ArrayList<>();
                        temp.add(stems.get(vari));
                        stemsWithTF.put(tfMatrix[vari],temp);
                    }
                }


                HashSet<Double> var7=new HashSet<>();
                var7.addAll(var1);
                var1.clear();
                var1.addAll(var7);
                Collections.sort(var1);


                int numberofstems= (int) (stems.size()*threshold);
                if (numberofstems==0) numberofstems++;

                ArrayList<Double> var3=new ArrayList<>();
                ArrayList<String> var4=new ArrayList<>();

                i=0;
                for(int j=var1.size()-1;j>=0;j--) {
                    double var5=var1.get(j);
                    for(String str:stemsWithTF.get(var5)) {
                        var4.add(str);
                        var3.add(var5);
                        i++;
                    }
                   // if(i>=numberofstems) break;
                }


                double[] var6=new double[var3.size()];
                for(int j=0;j<var3.size();j++) {
                    var6[j]=var3.get(j);
                }

               // System.out.println(numofStem+" "+var4.size());
                //outputTF(var4,var3);



                return new pair<>(var4,var6);
            }

            public static void outputTF(ArrayList<String> var0,ArrayList<Double> var5) {
                for (int i=0;i<var0.size();i++) {
                    System.out.println(var0.get(i)+" "+var5.get(i));
                }
            }

        }



