/*
       ///Set dataset format
        FastVector var0 = new FastVector();

        attributes.add(new Attribute("Assignee", (FastVector) null));

        attributes.add(new Attribute("Category", (FastVector) null));



        if (true) {
            for (int i = 0; i < patents.get(0).getTd().rows(); i++) {
                attributes.add(new Attribute("FullText" + Integer.toString(i)));

            }
            attributesNumber.put("FullText",patents.get(0).getTd().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_abs().rows(); i++) {
                attributes.add(new Attribute("Abstract" + Integer.toString(i)));

            }
            attributesNumber.put("Abstract",patents.get(0).getTd_abs().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_claims().rows(); i++) {
                attributes.add(new Attribute("Claims" + Integer.toString(i)));

            }
            attributesNumber.put("Claims",patents.get(0).getTd_claims().rows());
        }
        if (true) {

            for (int i = 0; i < patents.get(0).getTd_des().rows(); i++) {
                attributes.add(new Attribute("Description" + Integer.toString(i)));

            }
            attributesNumber.put("Description",patents.get(0).getTd().rows());
        }
        int index=0;

        for (Attribute var1 : attributes) {
            var0.addElement(var1);
            attributeIndex.put(var1.name(), index);
            index++;
        }

        this.attriInfo=new pair<>(attributeIndex,attributesNumber);

        //Initialize the dataset
        instances = new Instances("Patent", var0, patents.size());

        for (int i = 0; i < patents.size(); i++) {
            Instance var3 = new Instance(attributes.size());
            var3.setDataset(instances);
            var3.setValue(var3.attribute(attributeIndex.get("Assignee")), patents.get(i).getAssignee());
            var3.setValue(var3.attribute(attributeIndex.get("Category")), patents.get(i).getCategory());

            if ( true) {
                for (int j = 0; j < patents.get(0).getTd().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("FullText" + Integer.toString(j))), patents.get(i).getTd().get(j, 0));
                }
            }
            if (true) {
                for (int j = 0; j < patents.get(0).getTd_abs().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Abstract" + Integer.toString(j))), patents.get(i).getTd_abs().get(j, 0));
                }
            }
            if ( true) {
                for (int j = 0; j < patents.get(0).getTd_claims().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Claims" + Integer.toString(j))), patents.get(i).getTd_claims().get(j, 0));
                }
            }
            if ( true) {
                for (int j = 0; j < patents.get(0).getTd_des().rows(); j++) {
                    var3.setValue(var3.attribute(attributeIndex.get("Description" + Integer.toString(j))), patents.get(i).getTd_des().get(j, 0));
                }
            }
            instances.add(var3);
        }
        */



        package preprocessing;

        import base.pair;
        import base.patent;
        import com.carrotsearch.hppc.IntArrayList;
        import com.carrotsearch.hppc.IntIntHashMap;
        import com.carrotsearch.hppc.cursors.IntIntCursor;
        import org.apache.mahout.math.matrix.DoubleMatrix2D;
        import org.apache.mahout.math.matrix.impl.DenseDoubleMatrix2D;
        import org.carrot2.core.Document;
        import org.carrot2.core.LanguageCode;
        import org.carrot2.text.preprocessing.LabelFormatter;
        import org.carrot2.text.preprocessing.PreprocessingContext;
        import org.carrot2.text.preprocessing.pipeline.BasicPreprocessingPipeline;
        import org.carrot2.text.preprocessing.pipeline.CompletePreprocessingPipeline;
        import org.carrot2.text.preprocessing.pipeline.IPreprocessingPipeline;
        import org.carrot2.text.vsm.ReducedVectorSpaceModelContext;
        import org.carrot2.text.vsm.TermDocumentMatrixBuilder;
        import org.carrot2.text.vsm.TermDocumentMatrixReducer;
        import org.carrot2.text.vsm.VectorSpaceModelContext;


        import java.util.*;

        /**
         * Created by sunlei on 15/9/7.
         */
        public class patentPreprocessingTF {
            ArrayList<Document> docs = new ArrayList<>();
            ArrayList<patent> patents = new ArrayList<>();
            LanguageCode language = LanguageCode.ENGLISH;
            public int clusterCount = 15;
            public boolean useDimensionalityReduction = false;

            public IPreprocessingPipeline preprocessingPipeline = new BasicPreprocessingPipeline();
            public final TermDocumentMatrixBuilder matrixBuilder = new TermDocumentMatrixBuilder();

            public final TermDocumentMatrixReducer matrixReducer = new TermDocumentMatrixReducer();
            public final LabelFormatter labelFormatter = new LabelFormatter();

            public patentPreprocessingTF(ArrayList<patent> Pts) {
                this.patents = Pts;
                /**
                 * Set the matrix size to build the term frequency.
                 */
                this.matrixBuilder.maximumMatrixSize=250*150*4;
            }

            public void setLanguage(LanguageCode code) {
                this.language = code;
            }

            public void setClusterCount(int ClusterCount) {
                this.clusterCount = ClusterCount;
            }

            public void setUseDimensionalityReduction(boolean r) {
                this.useDimensionalityReduction = r;
            }

            public ArrayList<patent> getPatents()
            {
                return this.patents;
            }

            public void preprocess()
            {
        //        this.generateTextVector("FullText");
                this.generateTextVector("Abstract");
                this.generateTextVector("Claims");
                this.generateTextVector("Description");
                this.generateTextVector("Title");

            }

            public void generateTextVector(String str)
            {

                //Build arrayList of docs
                for (patent p : patents)
                {
                    String temp=" ";
                    if (str.equalsIgnoreCase("Abstract")) temp=p.getAbs();
                    if (str.equalsIgnoreCase("Claims"))   temp=p.getClaims();
                    if (str.equalsIgnoreCase("Description")) temp=p.getDescription();
                    if (str.equalsIgnoreCase("Title")) temp=p.getTitle();
                    pair<ArrayList<String>,double[]> var0;

                    if (!str.equalsIgnoreCase("Title")) {
                        var0 =TFcalculation(temp,1);
                    } else {
                        var0=TFcalculation(temp,1);
                    }
                    double[][] var1=new double[var0.secondarg.length][1];
                    int i=0;
                    for(double var2:var0.secondarg) {
                        var1[i][0]=var2;
                        i++;
                    }

                    if (str.equalsIgnoreCase("Abstract")) {
                        p.setTd_abs(new DenseDoubleMatrix2D(var1));
                        p.absStems=var0.firstarg;
                        //p.setAbs(null);
                    }
                    if (str.equalsIgnoreCase("Claims"))  {
                        p.setTd_claims(new DenseDoubleMatrix2D(var1));
                        p.claimsStems=var0.firstarg;
                      //  p.setClaims(null);
                    }
                    if (str.equalsIgnoreCase("Description")) {
                        p.setTd_des(new DenseDoubleMatrix2D(var1));
                        p.desStems=var0.firstarg;
                    //    p.setDescription(null);
                    }
                    if (str.equalsIgnoreCase("Title")) {
                        p.setTd_title(new DenseDoubleMatrix2D(var1));
                        p.titleStems=var0.firstarg;
                        //p.setTitle(null);
                    }


                }




            }


            public static pair<ArrayList<String>,double[]> TFcalculation(String var0,double threshold) {

                IPreprocessingPipeline preprocessingPipeline = new BasicPreprocessingPipeline();
                ArrayList<Document> docs = new ArrayList<>();
                docs.add(new Document(" ", var0));
                PreprocessingContext preprocessingContext = preprocessingPipeline.preprocess(docs, (String) null, LanguageCode.ENGLISH);
                int[] stemsMfow = preprocessingContext.allStems.mostFrequentOriginalWordIndex;
                short[] wordsType = preprocessingContext.allWords.type;


                IntArrayList featureIndices = new IntArrayList(stemsMfow.length);
                for (int vsmContext = 0; vsmContext < stemsMfow.length; ++vsmContext) {
                    short reducedVsmContext = wordsType[stemsMfow[vsmContext]];
                    if ((reducedVsmContext & 12290) == 0) {
                        featureIndices.add(stemsMfow[vsmContext]);
                    }
                }



                int[] stemType=new int[preprocessingContext.allStems.tf.length];
                for(int i=0;i<wordsType.length;i++) {
                    if((wordsType[i]&12290)!=0) {
                       stemType[preprocessingContext.allWords.stemIndex[i]]=0;
                    } else {
                        stemType[preprocessingContext.allWords.stemIndex[i]]=1;

                    }
                }


                int numofStem=0;
                for(int var=0;var<stemType.length;var++) {
                if (stemType[var]==1) numofStem++;
               }


                double[] tfMatrix = new double[numofStem];

                int i=0;
                for (int j = 0; j < preprocessingContext.allStems.tfByDocument.length; j ++) {
                   if (stemType[j]==1) {
                       tfMatrix[i]=preprocessingContext.allStems.tfByDocument[j][1];
                       i++;
                   }
                }

                double sum=0;

                for(double var1:tfMatrix) {
                    sum+=var1;
                }

                for(int vari=0;vari<tfMatrix.length;vari++) {
                    tfMatrix[vari]/=sum;
                }

                ArrayList<Double> var1=new ArrayList<>();

                for(double vari:tfMatrix) {
                    var1.add(vari);
                }


              //  System.out.println(preprocessingContext.allWords);

                //System.out.println(preprocessingContext.allStems);

                ArrayList<String> stems=new ArrayList<>();
                for(int vari=0;vari<preprocessingContext.allStems.tf.length;vari++) {

                   if(stemType[vari]==1) {
                    String varTemp=String.copyValueOf(preprocessingContext.allStems.image[vari]);
                    stems.add(varTemp);
                   }

                }
                HashMap<Double,ArrayList<String>> stemsWithTF=new HashMap<>();

                for(int vari=0;vari<tfMatrix.length;vari++) {
                    if(stemsWithTF.containsKey(tfMatrix[vari])) {
                        stemsWithTF.get(tfMatrix[vari]).add(stems.get(vari));
                    }
                    else {
                        ArrayList<String> temp=new ArrayList<>();
                        temp.add(stems.get(vari));
                        stemsWithTF.put(tfMatrix[vari],temp);
                    }
                }


                HashSet<Double> var7=new HashSet<>();
                var7.addAll(var1);
                var1.clear();
                var1.addAll(var7);
                Collections.sort(var1);


                int numberofstems= (int) (stems.size()*threshold);
                if (numberofstems==0) numberofstems++;

                ArrayList<Double> var3=new ArrayList<>();
                ArrayList<String> var4=new ArrayList<>();

                i=0;
                for(int j=var1.size()-1;j>=0;j--) {
                    double var5=var1.get(j);
                    for(String str:stemsWithTF.get(var5)) {
                        var4.add(str);
                        var3.add(var5);
                        i++;
                    }
                   // if(i>=numberofstems) break;
                }


                double[] var6=new double[var3.size()];
                for(int j=0;j<var3.size();j++) {
                    var6[j]=var3.get(j);
                }

               // System.out.println(numofStem+" "+var4.size());
                //outputTF(var4,var3);



                return new pair<>(var4,var6);
            }

            public static void outputTF(ArrayList<String> var0,ArrayList<Double> var5) {
                for (int i=0;i<var0.size();i++) {
                    System.out.println(var0.get(i)+" "+var5.get(i));
                }
            }

        }



1.0 0.006325235527063623 0.011127386125794676

3.0 0.0014616612656499692 0.0024957570578989963
3.1 0.001129686408244929 0.0018453354319843875
3.2 8.926126381678514E-4 0.0013803554420362158
3.3000000000000003 7.233208376504986E-4 0.001048044296896576
3.4000000000000004 6.013876488186775E-4 8.080912298772513E-4
3.5000000000000004 5.11819420929769E-4 6.314096303028116E-4
3.6000000000000005 4.467297916843995E-4 5.025604406924383E-4
3.7000000000000006 3.974574825466948E-4 4.0441647562603774E-4
3.8000000000000007 3.606456579725185E-4 3.306805184352509E-4
3.900000000000001 3.3262472971854173E-4 2.740065251270869E-4
4.0 3.1088222683379785E-4 2.2951689567097874E-4
4.0 3.1088222683379785E-4 2.2951689567097874E-4
4.1 2.9432096843770296E-4 1.9519371863359908E-4
4.199999999999999 2.813008857863416E-4 1.6773104053094268E-4
4.299999999999999 2.710224458609159E-4 1.4561688045098328E-4
4.399999999999999 2.630344153299193E-4 1.2790177789933317E-4
4.499999999999998 2.5671754752628375E-4 1.1340271577438281E-4
4.599999999999998 2.517643274671448E-4 1.016333337839853E-4
4.6999999999999975 2.4771880806852005E-4 9.176437067751937E-5
4.799999999999997 2.445795884136442E-4 8.351681444281186E-5
4.899999999999997 2.4217266689338865E-4 7.669189257132299E-5
4.9999999999999964 2.4023853314186563E-4 7.085532939067812E-5

4.8 2.4457958841364396E-4 8.351681444281151E-5
4.8999999999999995 2.4217266689338857E-4 7.669189257132265E-5
4.999999999999999 2.4023853314186555E-4 7.085532939067803E-5
5.099999999999999 2.3872996324407185E-4 6.593028733247658E-5
5.199999999999998 2.3761828909180848E-4 6.167058371492901E-5
5.299999999999998 2.3678309411597729E-4 5.805010735590339E-5
5.399999999999998 2.3619452756877183E-4 5.493068107031279E-5
5.499999999999997 2.3586842326483228E-4 5.219946701382285E-5
5.6 2.3567613662712006E-4 4.983101832524648E-5

800
4.0 0.9973278563520409 0.005713756073308423
4.1 0.9974833597122925 0.005219686078822696
4.199999999999999 0.9976366135150082 0.004775861398259487
4.299999999999999 0.9977790681356629 0.004388122323892425
4.399999999999999 0.9979125651217433 0.0040419033104017645
4.499999999999998 0.9980371304842238 0.003731902947388073
4.599999999999998 0.9981493665289488 0.003458465578355065
4.6999999999999975 0.9982504891952833 0.0032171417370820184
4.799999999999997 0.9983460732299101 0.0029943558699107656
4.899999999999997 0.9984316946279419 0.0027972961699126516
4.9999999999999964 0.9985080624607278 0.0026228716406045175
